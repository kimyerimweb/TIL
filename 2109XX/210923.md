## 210923 TIL

### 오늘 배운 것

- Transport 계층

- End to End 서비스로 네트워크 계층은 다른 IP를 가진 라우터라는 것을 경유해서 이동하지만, 전송 계층은 단말과 단말인 양 끝이 1대 1로 바로 연결된 논리적인 연결이다.

- TCP와 UDP의 차이점
<p>TCP는 전송 제어 프로토콜으로 송신측과 수신측이 커넥션을 형성해, 데이터에 오류없이 신뢰도 높은 상태로 전달해야한다. UDP는 사용자 데이터그램 프로토콜으로 연결없이 송신측이 다수의 수신자에게 데이터를 전송하며, 오류가 발생해도 재전송 하지 않는다. UDP는 대신 속도가 빠르기 때문에 실시간 스트리밍에 적합하다. TCP는 정확한 데이터 전달을 필요로 하는 메일 서비스 등에 적합하다.
</p>

- TCP 초기 연결은 TCP 3-way handshake를 사용한다. TCP 커넥션을 수립한다.

1. 클라이언트가 서버쪽으로 Syn 패킷을 보낸다.
2. 서버가 클라이언트 쪽으로 Syn/Ack을 보낸다.
3. 클라이언트가 서버쪽으로 Ack을 보낸다.
   (위 단계는 한번도 실패하지 않는다는 가정 하에 흐름이다.)

- TCP 연결 종료는 TCP 4-way handshake를 사용한다.

1. 클라이언트가 서버쪽으로 FIN 패킷을 보낸다.
2. 서버가 클라이언트로 ACK을 보낸다.
3. 서버가 다시 클라이언트에게 FIN을 보낸다.
4. 클라이언트가 서버쪽으로 ACK을 보낸다.

- TCP 타이머

1. Retransmission: RTO(Retransmission Timeout)내에 ACK 응답이 오지 않으면 재전송한다.
2. Persistence: 수신측 윈도우 사이즈가 0이면 타이머가 가동된다. 타이머가 종료되면 다시 Probe(ACK 재전송 요청)를 보낸다.
   - 윈도우 사이즈 = 마지막으로 수신한 데이터 사이즈 - 프로세스가 처리한 데이터 사이즈
3. Time waited: 다른 연결이 맺어진 상태에서 이전 연결의 지연/중복 패킷이 도착했을 때 처리하기 위해 TCP연결 종료 후에도 특정 시간만 연결을 유지한다.
4. KeepAlive: TCP 연결을 맺었지만 수신측에서 2시간동안 받은 패킷이 없으면 수신측이 서버에 Probe를 전송한다. 9개를 보내고도 응답이 없으면 연결종료. 있으면 다시 카운트

- Flow Control: 수신측과 송신측의 데이터 처리 속도 차이를 해결한다.
  원도우 사이즈를 이용한다.

- Congestion Control: 수신측으로 유입되는 트래픽 양이 정해진 대역폭을 넘어가지 않게 제어한다.

### 오늘의 느낀점

TCP와 UDP의 차이점은 전통있는(?) 면접 단골질문이다. 하지만 나머지는 중요도가 떨어지는지 딱히 문제로 나와있는 것이 없다.

### 앞으로의 계획

- 어플리케이션 범위 인강 학습
