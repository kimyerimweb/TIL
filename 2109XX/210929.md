## 210929 TIL

### 오늘 배운 것

- 스레드와 프로세스
<p>
프로세스 하나에 CPU 수행 단위를 여러개 뒀을 때, 각각의 수행 단위를 스레드라고 한다.<br/>
CPU의 수행 단위가 여러개이지만 근본적으로 프로세스 하나에 종속되어 있기 때문에, 공유하는 자원이 존재하고,
구분되어 독립적으로 사용하는 자원이 존재한다.<br/>
스레드는 lightweight process라고 부른다.<br/>
전통적인 프로세스는 heavyweight process라고 부른다.
</p>

- 스레드의 구성

1. 프로그램 카운터
2. 레지스터 set (연산을 수행하고 결과들을 일차적으로 저장하는 장소라고 이해한다.)
3. 스택 공간

- 스레드가 같은 프로세스 내부의 스레드와 공유하는 부분(=task)

1. code 공간
2. data 공간
3. OS 리소스

- 스레드의 장점

1. 다중 스레드로 구성되어 있으면 동일 태스크 내의 어떤 스레드가 blocked된 상태일지라도 다른 스레드를 실행하면 되기 때문에 처리를 빠르게 할 수 있다.
2. 동일한 작업을 처리하는 스레드를 서로 다른 CPU에서 실행해 병렬적으로 처리해 성능을 향상시킬 수 있다. (CPU가 여러개 달려 있을 때만 가능)
3. 자원을 절약할 수 있다. (같은 일을 하는 프로세스를 여러개 두지 않고 스레드로 놓으면 코드, 데이터 공간을 공유할 수 있어서 절약 가능)
   <br/>

- 프로세스의 생성과 종료, 그밖의 시스템 콜
<p>부모 프로세스가 자식 프로세스를 생성한다.<br/>

1. fork()를 이용해서 복제함.
<p>
자식 프로세스는 부모 프로세스의 내용을 그대로 복사해온다.
하지만 자식 프로세스는 pid가 0이고 부모 프로세스는 양수로 구분된다.
그대로 복사해올 때, PC도 복사해오기 때문에 fork() 이후의 코드부터 실행된다. (fork()는 이미 실행되었음.)
</p>

2. fork()로 복사한 후 exec()로 새로운 코드로 덮어씌움
<p>
fork()까지는 위와 맥락이 동일하다.
하지만 exec()를 만나면, 함수의 인자로 작성한 파일 경로에 있는 파일의 코드로 완전히 덮어씌워진다.
자식 프로세스는 완전히 새롭게 덮어씌워진 파일의 코드대로 실행되고 종료된다.
다시 부모 프로세스가 가지고 있던 원래 코드의 맥락으로 돌아오진 않는다.
(사실 exec는 자식을 만들어야만 사용할 수 있는 것은 아니고 언제든 사용 가능하다.)
</p>

3. wait()
<p>
보통 자식 프로세스를 만들고 wait()를 호출한다.
커널은 자식이 종료될 때까지 부모 프로세스를 sleep 시킨다. (block 상태)
자식 프로세스가 종료되면 커널이 부모 프로세스를 깨워 ready상태로 돌려놓는다. 
</p>

4. exit()
<p>
프로세스가 종료된다.

- 자발적인 종료

1. exit() 시스템 콜을 호출하는 코드를 작성한다.
2. 굳이 작성하지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어준다.

- 비자발적인 종료 (외부적인 요인으로 종료)

1. 부모 프로세스가 종료될 때 자식들이 먼저 종료되어야해서 종료된다.
2. 키보드로 kill이나 break를 입력했다.
3. 부모 프로세스가 자식 프로세스를 필요없어하거나 자원을 너무 먹어서 강제로 종료시켰다.
</p>

- 프로세스 간 협력

1. 독립적 프로세스: 원칙적으로는 서로 다른 프로세스의 수행에 영향을 끼치지 못한다.
2. 협력 프로세스: 협력 메커니즘(IPC:interprocess Communication)을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있다.
3. IPC

- message passing: 커널을 통해 메시지 전달
- shared memory: 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 매커니즘
- thread: 사실상 하나의 프로세스를 나눈 것이기에 프로세스간의 협력으로 보기는 어렵지만, 동일한 프로세스를 구성하는 스레드간에는 주소 공간을 공유하므로 협력이 가능하다.

프로세스의 특성

1. I/O bound process -> CPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 job
2. CPU-bound process -> 계산 위주의 job

CPU 스케쥴러: Ready 상태의 프로세스 중에서 이번에 CPU를 줄 프로세스를 고른다. 스케쥴링을 담당하는 코드 부분을 스케쥴러라고 부른다.

Dispatcher: CPU의 제어권을 프로세스에게 넘겨주는 일을 담당한다. 이 과정을 context switch라고 한다.

CPU 스케쥴링이 필요한 경우

1. Running -> Blocked (자진 반납 - nonpreemtive)
2. Running -> Ready (강제로 빼앗김 - preemtive)
3. Blocked -> Ready (강제로 빼앗김)
4. Terminate (자진 반납)
   Ready에서 Running으로 넘어가는 경우를 제외하고는 모든 과정에서 필요하다고 생각하면 된다.
   굳이 이 과정을 구분할 필요는 없다.
   preemtive와 nonpreemtive만 제대로 이해하고 외우면 된다.

### 오늘의 느낀 점

<p>운영체제 공룡책이랑 강의의 진도를 나가는 순서가 다른 것 같다. 강의를 빨리 듣고 책으로 차분히 내용을 복습해야겠다.</p>
<p>슬랙 클론코딩은 하긴 해야한다는 생각이 들지만..속이 별로 안좋아서 강의라도 꾸역꾸역 듣기로 계획을 세웠다.</p>

### 앞으로의 계획

운영체제 강의 다듣고 공룡책으로 복습하면서 슬랙 클론코딩 꼭 하기
