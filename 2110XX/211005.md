CPU 스케쥴링 이슈

스케쥴링은 왜 필요한가?
-> 사람들과 상호작용을 많이 하는 job과 그렇지 않은 job이 섞여있기 때문에

1. CPU burst에 들어온 프로세스들 중에 누구에게 CPU를 할당해줄 것인가?
2. CPU를 계속 점유하게 할 것인가? 중간에 뺏어올 것인가?

CPU 스케쥴링 알고리즘

1. nonpreemtive한 알고리즘 (안뺏고 점유 계속 하도록)

- FCFS (First-Come First-Served, 앞 순서의 프로세스가 너무 오래 점유하면 곤란해진다.)
- SJF (Shortest Job First, 평균 대기 시간이 가장 짧아진다고 알려져있다. 하지만 nonpreemtive한 방법은 현재 실행중인 프로세스보다 짧은 프로세스가 와도 끝날 때까지 독점한다. 문제점은 starvation 상태가 발생할 수 있고 애초에 CPU를 사용하는 시간을 미리 알 수가 없다는 것이 문제이다. 과거 사용 흔적으로 예측은 할 수 있다.)

2. preemtive한 알고리즘 (중간에 강제로 빼앗음, 현대에는 보통 이걸 씀)

- SMTF (shortest remaining time first, sjf의 preemtive버전이라고 이해하면 편하다. 남은 시간이 더 짧은 프로세스가 오면(이미 실행하던 프로세스는 실행하고 남은 시간을 기준으로 한다.) CPU를 사용중이던 프로세스에게서 CPU를 빼앗고 가장 짧은 프로세스에게 CPU를 넘긴다. 이게 average waiting time을 가장 짧게 만든다.)

- RR (Round Robin) 프로세스는 동일한 할당 시간을 가지고 프로세스가 번갈아가며 CPU를 얻는다. 응답 시간이 줄어든다는 장점이 있다. 그리고 어떤 프로세스가 CPU를 길게 쓸지 예측하지 않아도 괜찮다. 단점으로는 무조건 일정 이상의 waiting time이 존재한다.

3. multilevel queue : 큐가 여러 개로 나뉘어 있고 큐마다 우선순위가 나뉘어 있다. 가장 우선 순위가 높은 큐에 있는 프로세스부터 처리한다. 그리고 큐마다 독립적인 스케쥴링 알고리즘을 가진다. 사람들과 인터랙션이 많은 큐는 RR을 사용해 응답시간을 줄이고 인터랙션이 없는 큐는 FCFS로 크게 신경쓰지 않는다. 단, 각 큐의 우선순위만을 고려하면 starvation이 나타날 수 있기 때문에 일정 시간은 우선순위가 낮은 큐에게도 할당하는 방식을 이용한다.

4. multilevel feedback queue : 프로세스의 우선 순위가 바뀐다. 큐의 수, 우선순위를 바꾸는 기준등이 정해져야한다. 보통은 처음 들어오는 프로세스는 가장 우선순위가 높은 큐에 넣고 대신 RR에서 실행시간을 짧게 준다. 그리고 우선 순위가 낮은 큐로 이동하면서 점점 실행시간을 길게 준다. 마지막 큐에 들어온 프로세스는 FCFS로 처리한다.

성능 척도 (ready 큐에 들어온 프로세스들만 가지고 단위 시간당 몇개 이런 식으로 생각해야한다.)

1. 시스템 입장에서 성능 척도 -> 놀지 않고 많이 일하도록

- CPU utilization(이용률) : 전체 시간 중 CPU가 놀지 않고 일하는 시간 (최대한 많이 일하게 만들어야한다.)
- Throughtput (처리량) : 주어진 시간동안 몇개의 작업을 완료했는가

2. 프로그램 입장에서 성능 척도 -> 가능하면 빨리 일을 끝내자

- Turnaround time(소요시간, 반환시간) : CPU를 쓰러와서 다 쓰고 나갈 때까지 시간
- Waiting time(대기 시간) : ready 큐에서 기다리는 시간
- Response time(응답 시간) : ready 큐에서 CPU를 처음으로 얻기까지 기다린 시간
  Waiting time은 얻었다가 뺏기고 다시 얻는 과정을 반복하면서 발생한 대기 시간을 모두 합한 개념이고 Response time은 처음 CPU를 얻기까지 대기 시간일뿐이다.

비유적으로 이해하기(중국집)
-> 전체 영업시간 중에 주방장이 놀지 않고 일한 비율 : CPU utilization
-> 단위 시간당 손님 몇명을 밥을 먹여서 내보내는가? : Throughtput
-> 손님 입장에서 중국집에서 식사를 주문하고 기다렸다가 다 먹고 나갈때까지 걸리는 시간 (하나만 시켜서 빨리 먹고 나갈수도 있고, 코스요리라서 오리 기다릴 수도 있고, 손님이 너무 많아서 첫 음식도 늦게 나올 수도 있고) : Turnaround time
-> 밥먹는 시간 말고 기다리는 시간의 총 합 : Waiting time
-> 첫 음식이 나올 때까지 기다리는 시간 : Response time

convoy effect: 짧은 프로세스가 긴 프로세스 뒤에서 대기하면서 전체 대기 시간(wating time)이 길어지는 현상 (좋지 않음)

starvation: 짧은 프로세스만 실행하다가 긴 프로세스는 영원히 실행할 수 없을 수도 있다.
